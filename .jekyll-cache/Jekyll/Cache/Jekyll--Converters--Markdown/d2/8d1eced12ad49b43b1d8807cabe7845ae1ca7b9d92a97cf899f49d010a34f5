I"!i<h1 id="lecture-13-nn-网络层池化层全连接层和激活函数层">Lecture 13 nn 网络层：池化层、全连接层和激活函数层</h1>

<p>上节课中，我们学习了网络层中的卷积层。本节课中，我们将继续学习其他几种网络层：池化层、线性层和激活函数层。</p>

<h2 id="1-池化层">1. 池化层</h2>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-12-16-mp.gif" width="60%" /></p>

<p><strong>池化运算 (Pooling)</strong>：对信号进行 <strong>“收集”</strong> 并 <strong>“总结”</strong>，类似水池收集水资源，因而得名池化层。</p>

<ul>
  <li><strong>“收集”</strong>：多变少。</li>
  <li><strong>“总结”</strong>：最大值/平均值。</li>
</ul>

<p><strong>最大池化 vs. 平均池化</strong>：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-12-16-Illustration-of-Max-Pooling-and-Average-Pooling-Figure-2-above-shows-an-example-of-max.png" width="60%" /></p>

<h4 id="nnmaxpool2d"><code class="language-plaintext highlighter-rouge">nn.MaxPool2d</code></h4>

<p><strong>功能</strong>：对二维信号（图像）进行最大值池化。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="n">nn</span><span class="p">.</span><span class="n">MaxPool2d</span><span class="p">(</span>
    <span class="n">kernel_size</span><span class="p">,</span>
    <span class="n">stride</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
    <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">return_indices</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
    <span class="n">ceil_mode</span><span class="o">=</span><span class="bp">False</span>
<span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>主要参数</strong>：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">kernel_size</code>：池化核尺寸。</li>
  <li><code class="language-plaintext highlighter-rouge">stride</code>：步长。</li>
  <li><code class="language-plaintext highlighter-rouge">padding</code>：填充个数。</li>
  <li><code class="language-plaintext highlighter-rouge">dilation</code>：池化核间隔大小。</li>
  <li><code class="language-plaintext highlighter-rouge">ceil_mode</code>：尺寸是否向上取整。用于计算输出特征图尺寸，默认设置为向下取整。</li>
  <li><code class="language-plaintext highlighter-rouge">return_indices</code>：记录池化像素索引。通常在最大值反池化上采样时使用。</li>
</ul>

<p><strong>代码示例</strong>：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">transforms</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">tools.common_tools</span> <span class="kn">import</span> <span class="n">transform_invert</span><span class="p">,</span> <span class="n">set_seed</span>

<span class="n">set_seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># 设置随机种子
</span>
<span class="c1"># ================================= load img ==================================
</span><span class="n">path_img</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">__file__</span><span class="p">)),</span> <span class="s">"lena.png"</span><span class="p">)</span>
<span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="n">path_img</span><span class="p">).</span><span class="n">convert</span><span class="p">(</span><span class="s">'RGB'</span><span class="p">)</span>  <span class="c1"># 0~255
</span>
<span class="c1"># convert to tensor
</span><span class="n">img_transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">.</span><span class="n">Compose</span><span class="p">([</span><span class="n">transforms</span><span class="p">.</span><span class="n">ToTensor</span><span class="p">()])</span>
<span class="n">img_tensor</span> <span class="o">=</span> <span class="n">img_transform</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="n">img_tensor</span><span class="p">.</span><span class="n">unsqueeze_</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>    <span class="c1"># C*H*W to B*C*H*W
</span>
<span class="c1"># ========================== create maxpool layer =============================
</span><span class="n">maxpool_layer</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">MaxPool2d</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>   <span class="c1"># input:(i, o, size) weights:(o, i , h, w)
</span><span class="n">img_pool</span> <span class="o">=</span> <span class="n">maxpool_layer</span><span class="p">(</span><span class="n">img_tensor</span><span class="p">)</span>

<span class="c1"># ================================= visualization =============================
</span><span class="k">print</span><span class="p">(</span><span class="s">"池化前尺寸:{}</span><span class="se">\n</span><span class="s">池化后尺寸:{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">img_tensor</span><span class="p">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">img_pool</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>
<span class="n">img_pool</span> <span class="o">=</span> <span class="n">transform_invert</span><span class="p">(</span><span class="n">img_pool</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">...],</span> <span class="n">img_transform</span><span class="p">)</span>
<span class="n">img_raw</span> <span class="o">=</span> <span class="n">transform_invert</span><span class="p">(</span><span class="n">img_tensor</span><span class="p">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">img_transform</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">).</span><span class="n">imshow</span><span class="p">(</span><span class="n">img_pool</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">).</span><span class="n">imshow</span><span class="p">(</span><span class="n">img_raw</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>输出结果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>池化前尺寸:torch.Size([1, 3, 512, 512])
池化后尺寸:torch.Size([1, 3, 256, 256])
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-12-16-WX20201216-193358%402x.png" width="60%" /></p>

<p>可以看到，经过最大池化后的图像尺寸减小了一半，而图像质量并没有明显降低。因此，池化操作可以剔除图像中的冗余信息，以及减小后续的计算量。</p>

<h4 id="nnavgpool2d"><code class="language-plaintext highlighter-rouge">nn.AvgPool2d</code></h4>

<p><strong>功能</strong>：对二维信号（图像）进行平均值池化。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="n">nn</span><span class="p">.</span><span class="n">AvgPool2d</span><span class="p">(</span>
    <span class="n">kernel_size</span><span class="p">,</span>
    <span class="n">stride</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
    <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">ceil_mode</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
    <span class="n">count_include_pad</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="n">divisor_override</span><span class="o">=</span><span class="bp">None</span>
<span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>主要参数</strong>：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">kernel_size</code>：池化核尺寸。</li>
  <li><code class="language-plaintext highlighter-rouge">stride</code>：步长。</li>
  <li><code class="language-plaintext highlighter-rouge">padding</code>：填充个数。</li>
  <li><code class="language-plaintext highlighter-rouge">ceil_mode</code>：尺寸向上取整。</li>
  <li><code class="language-plaintext highlighter-rouge">count_include_pad</code>：是否将填充值用于平均值的计算。</li>
  <li><code class="language-plaintext highlighter-rouge">divisor_override</code>：除法因子。计算平均值时代替像素个数作为分母。</li>
</ul>

<p><strong>代码示例</strong>：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">transforms</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">tools.common_tools</span> <span class="kn">import</span> <span class="n">transform_invert</span><span class="p">,</span> <span class="n">set_seed</span>

<span class="n">set_seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># 设置随机种子
</span>
<span class="c1"># ================================= load img ==================================
</span><span class="n">path_img</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">__file__</span><span class="p">)),</span> <span class="s">"lena.png"</span><span class="p">)</span>
<span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="n">path_img</span><span class="p">).</span><span class="n">convert</span><span class="p">(</span><span class="s">'RGB'</span><span class="p">)</span>  <span class="c1"># 0~255
</span>
<span class="c1"># convert to tensor
</span><span class="n">img_transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">.</span><span class="n">Compose</span><span class="p">([</span><span class="n">transforms</span><span class="p">.</span><span class="n">ToTensor</span><span class="p">()])</span>
<span class="n">img_tensor</span> <span class="o">=</span> <span class="n">img_transform</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="n">img_tensor</span><span class="p">.</span><span class="n">unsqueeze_</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>    <span class="c1"># C*H*W to B*C*H*W
</span>
<span class="c1"># ========================== create avgpool layer =============================
</span><span class="n">avgpoollayer</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">AvgPool2d</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>   <span class="c1"># input:(i, o, size) weights:(o, i , h, w)
</span><span class="n">img_pool</span> <span class="o">=</span> <span class="n">avgpoollayer</span><span class="p">(</span><span class="n">img_tensor</span><span class="p">)</span>

<span class="c1"># =============================== visualization ===============================
</span><span class="k">print</span><span class="p">(</span><span class="s">"池化前尺寸:{}</span><span class="se">\n</span><span class="s">池化后尺寸:{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">img_tensor</span><span class="p">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">img_pool</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>
<span class="n">img_pool</span> <span class="o">=</span> <span class="n">transform_invert</span><span class="p">(</span><span class="n">img_pool</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">...],</span> <span class="n">img_transform</span><span class="p">)</span>
<span class="n">img_raw</span> <span class="o">=</span> <span class="n">transform_invert</span><span class="p">(</span><span class="n">img_tensor</span><span class="p">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">img_transform</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">).</span><span class="n">imshow</span><span class="p">(</span><span class="n">img_pool</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">).</span><span class="n">imshow</span><span class="p">(</span><span class="n">img_raw</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>输出结果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>池化前尺寸:torch.Size([1, 3, 512, 512])
池化后尺寸:torch.Size([1, 3, 256, 256])
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-12-16-WX20201216-195332%402x.png" width="60%" /></p>

<p>同样，图像尺寸减小了一半，而质量并没有明显降低。另外，如果我们仔细对比最大池化与平均池化的结果，可以发现最大池化后的图像会偏亮一些，而平均池化后的图像会偏暗一些，这是由于两种池化操作采用不同的计算方式造成的 (像素值越大，图像亮度越高)。</p>

<h5 id="divisor_override-的使用"><code class="language-plaintext highlighter-rouge">divisor_override</code> 的使用</h5>

<p>现在，我们来看一下除法因子的使用。这里，我们初始化一个 $4\times 4$ 的图像，并且采用一个 $2\times 2$ 的窗口，步长设置为 $2$。</p>

<p><strong>正常的平均池化</strong>：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="n">img_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">avgpool_layer</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">AvgPool2d</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">img_pool</span> <span class="o">=</span> <span class="n">avgpool_layer</span><span class="p">(</span><span class="n">img_tensor</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"raw_img:</span><span class="se">\n</span><span class="s">{}</span><span class="se">\n</span><span class="s">pooling_img:</span><span class="se">\n</span><span class="s">{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">img_tensor</span><span class="p">,</span> <span class="n">img_pool</span><span class="p">))</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>输出结果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>raw_img:
tensor([[[[1., 1., 1., 1.],
          [1., 1., 1., 1.],
          [1., 1., 1., 1.],
          [1., 1., 1., 1.]]]])
pooling_img:
tensor([[[[1., 1.],
          [1., 1.]]]])
</pre></td></tr></tbody></table></code></pre></div></div>

<p>计算池化后的像素值：</p>

\[\dfrac{1+1+1+1}{4} = 1\]

<p><strong><code class="language-plaintext highlighter-rouge">divisor_override=3</code> 的平均池化</strong>：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="n">img_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">avgpool_layer</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">AvgPool2d</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">divisor_override</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">img_pool</span> <span class="o">=</span> <span class="n">avgpool_layer</span><span class="p">(</span><span class="n">img_tensor</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"raw_img:</span><span class="se">\n</span><span class="s">{}</span><span class="se">\n</span><span class="s">pooling_img:</span><span class="se">\n</span><span class="s">{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">img_tensor</span><span class="p">,</span> <span class="n">img_pool</span><span class="p">))</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>输出结果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>raw_img:
tensor([[[[1., 1., 1., 1.],
          [1., 1., 1., 1.],
          [1., 1., 1., 1.],
          [1., 1., 1., 1.]]]])
pooling_img:
tensor([[[[1.3333, 1.3333],
          [1.3333, 1.3333]]]])
</pre></td></tr></tbody></table></code></pre></div></div>

<p>计算池化后的像素值：</p>

\[\dfrac{1+1+1+1}{3} = 1.3333\]

<p>目前为止，我们学习了最大池化和平均池化，它们都是对图像实现下采样的过程，即输入尺寸较大的图像，输出尺寸较小的图像。下面我们将学习反池化，即将小尺寸图像变为大尺寸图像。</p>

<h4 id="nnmaxunpool2d"><code class="language-plaintext highlighter-rouge">nn.MaxUnpool2d</code></h4>

<p><strong>功能</strong>：对二维信号（图像）进行最大值反池化上采样。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>
<span class="n">nn</span><span class="p">.</span><span class="n">MaxUnpool2d</span><span class="p">(</span>
    <span class="n">kernel_size</span><span class="p">,</span>
    <span class="n">stride</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
    <span class="n">padding</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>

<span class="n">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>主要参数</strong>：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">kernel_size</code>：池化核尺寸。</li>
  <li><code class="language-plaintext highlighter-rouge">stride</code>：步长。</li>
  <li><code class="language-plaintext highlighter-rouge">padding</code>：填充个数。</li>
</ul>

<p><strong>最大值反池化：</strong></p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-12-16-111500.png" width="80%" /></p>

<p>早期的自编码器和图像分割任务中都会涉及一个上采样的操作，当时普遍采用的方法是最大值反池化上采样。上图左半部分是最大池化过程，原始 $4\times 4$ 的图像经过最大池化后得到一个 $2\times 2$ 的下采样图像，然后经过一系列的网络层之后，进入上图右半部分的上采样解码器，即将一个尺寸较小的图像经过上采样得到一个尺寸较大的图像。此时，涉及到的一个问题是：我们应该将像素值放到什么位置。例如：右边 $2\times 2$ 图像中的左上角的 $3$ 应当放入最终 $4\times 4$ 图像中的左上部分的 $4$ 个像素中的哪一个？这时，我们就可以利用之前最大池化过程中记录的池化像素索引，将 $3$ 放入之前原始 $4\times 4$ 图像中左上角的 $4$ 个像素中最大值对应的位置。</p>

<p><strong>代码示例</strong>：</p>

<p>这里，我们初始化一个 $4\times 4$ 的图像，并且采用一个 $2\times 2$ 的窗口，步长设置为 $2$。首先，我们对其进行最大值池化，并记录其中的最大值索引</p>

<p>下节内容：nn 网络层：池化层、全连接层和激活函数层</p>
:ET